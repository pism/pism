# Copyright (C) 2011 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM, math
from PISM import util, netCDF

SSAAlgorithms = {"fem":PISM.SSAFEM, "fd":PISM.SSAFD }

class SSASolver:
  def __init__(self,grid,config=None):
    self.grid = grid
    if config is None: config = grid.config
    self.config = config

    # Variables for the physics
    self.ice   = None
    self.basal = None
    self.enthalpyconverter = None

    self.surface       = None
    self.drivingstress = None

    self.thickness     = None
    self.bed           = None
    self.tauc          = None
    self.enthalpy      = None
    self.ice_mask      = None
      
    self.vel_bc     = None
    self.bc_mask    = None
  
    self.setFromOptions()

    self.ssa = None

    self.vel_ssa = None

    self.ssa_init = False

  def setPhysics(self,ice,basal,enthalpyconverter):
    self.ice = ice;
    self.basal = basal;
    self.enthalpyconverter = enthalpyconverter;

  def buildSSA(self):
    self.ssa = SSAAlgorithms[self.config.get_string("ssa_method")](self.grid,self.basal,self.ice,self.enthalpyconverter,self.config)

  def allocateCoeffs(self,using_explicit_driving_stress=False):
    grid = self.grid
    
    if(using_explicit_driving_stress):
      self.drivingstress = util.standardDrivingStress( grid )
    else:
      self.surface    = util.standardIceSurfaceVec( grid )
    self.thickness  = util.standardIceThicknessVec( grid )
    self.bed        = util.standardBedrockElevationVec( grid )
    self.tauc       = util.standardYieldStressVec( grid )
    self.enthalpy   = util.standardEnthalpyVec( grid )
    self.ice_mask   = util.standardIceMask( grid )

  def setFromOptions(self):
    for o in PISM.OptionsGroup(self.grid.com,"","SSA options"):
      (ssa_method,wasSet) = PISM.optionsListWasSet(self.grid.com, "-ssa_method", 
                                    "Algorithm for computing the SSA solution",
                                    ["fem","fd"], "fd")
      if wasSet: self.config.set_string("ssa_method",ssa_method);
      self.config.scalar_from_option("ssa_epsfd",  "epsilon_ssafd");
      self.config.scalar_from_option("ssa_maxi", "max_iterations_ssafd");
      self.config.scalar_from_option("ssa_rtol", "ssafd_relative_convergence");

  def allocateBCs(self,velname='_bc',maskname='bc_mask'):
    self.vel_bc     = util.standard2dVelocityVec( self.grid, name=velname, desc='SSA velocity boundary condition',intent='intent' )
    self.bc_mask    = util.standardBCMask( self.grid,name=maskname )

  def readCoeffsFromFile(self,filename,omit=None):
    # Variables that are always used.
    vars = set([self.surface,self.bed,self.tauc,self.enthalpy,self.ice_mask])

    # Optional variables
    if not self.thickness is None:
      vars.add(self.thickness)
    if not self.drivingstress is None:
      vars.add(self.drivingstress)
    if not self.vel_bc is None:
      vars.add(self.vel_bc); vars.add(self.bc_mask)

    # Remove variables that are not needed.
    if not omit is None:
      vars.difference_update(omit)
    
    # We've got our list.  Read them in
    for v in vars:
      v.regrid(filename,True)

  def solve(self):
    if not self.ssa_init:
      pismVars = PISM.PISMVars()
      for var in [self.thickness,self.bed,self.tauc,self.enthalpy,self.ice_mask]:
        pismVars.add(var)
      if not self.surface is None:
        pismVars.add(self.surface)
      if not self.drivingstress is None:
        print 'adding driving stress'
        print self.drivingstress.string_attr("name")
        pismVars.add(self.drivingstress,'ssa_driving_stress')

      # The SSA instance will not keep a reference to pismVars; it only uses it to extract
      # its desired variables.  So it is safe to pass it pismVars and then let pismVars
      # go out of scope at the end of this method.
      self.ssa.init(pismVars)

      if not self.vel_bc is None:
        self.ssa.set_boundary_conditions(self.bc_mask,self.vel_bc)
      self.ssa_init = True
    
    PISM.verbPrintf(2,self.grid.com,"* Solving the SSA stress balance ...\n");
    fast = False;
    self.ssa.update(fast);
    self.vel_ssa = self.ssa.get_advective_2d_velocity()

  def solution(self):
    return self.vel_ssa

  def write(self,filename):
    vars = [self.surface,self.drivingstress,self.bed,self.thickness,self.tauc,self.enthalpy,self.ice_mask]
    for var in vars:
      if not var is None:
        var.write(filename)
    
    if not self.vel_ssa is None:
      vel_ssa = self.vel_ssa;
      vel_ssa.write(filename)
    
      cbar = util.standardCBar(self.grid);
      vel_ssa.magnitude(cbar)
      cbar.mask_by(self.thickness,-0.01/PISM.secpera);
    
      cbar.write(filename)


class SSARun:
  def __init__(self):
    self.grid = None
    self.config = None
    self.solver = None
  
  def setup(self):
    self._setFromOptions()
    
    self._initGrid()
    if self.grid == None:
      raise RuntimeError("SSARun failed to provide a grid.")
    self.config = self.grid.config

    self.solver = self._constructSSA()
    if self.solver == None:
      raise RuntimeError("SSARun failed to provide an SSA solver.")

    self._initPhysics()
    if (self.solver.ice == None) or (self.solver.basal == None) or (self.solver.enthalpyconverter == None):
      raise RuntimeError("SSARun._initPhysics failed to initialize the physics of the underlying SSA solver.")

    self._initSSACoefficients()
    # FIXME: is there a reasonable check to do here?

    self.solver.buildSSA()
    self._initSSA()

  def teardown(self):
    pass

  #//! Solve the SSA
  def solve(self):
    self.solver.solve()

  def write(self,filename):
    grid = self.grid
    
    pio = PISM.PISMIO(grid)
    pio.open_for_writing(filename,False,True)
    pio.append_time(grid.config.get_string("time_dimension_name"),0.0)
    pio.close()
    
    # Save time & command line
    PISM.util.writeProvenance(filename)
    
    self.solver.write(filename)

  def _setFromOptions(self):
    pass

  def _constructSSA(self):
    return SSASolver(self.grid)

  def _initGrid(self):
    raise NotImplementedError()
    
  def _initPhysics(self):
    raise NotImplementedError()
  
  def _initSSACoefficients(self):
    raise NotImplementedError()

  def _initSSA(self):
    pass

class SSAExactTestCase(SSARun):
  def __init__(self,Mx,My):
    SSARun.__init__(self)
    self.Mx = Mx; self.My = My;

    # For convenience, provide a grid. It will get initialized later
    # on when _initGrid is called by our setup method.
    self.grid = PISM.Context().newgrid()
  
  def run(self,output_file):
    self.setup()
    self.solve()
    self.report()
    self.write(output_file)
    self.teardown()
  
  def report(self):
      grid = self.grid

      ssa_stdout = self.solver.ssa.stdout_report()
      PISM.verbPrintf(3,grid.com,ssa_stdout)

      maxvecerr = 0.0; avvecerr = 0.0; 
      avuerr = 0.0; avverr = 0.0;
      maxuerr = 0.0; maxverr = 0.0;

      if(self.config.get_flag("do_pseudo_plastic_till")):
        PISM.verbPrintf(1,grid.com, "WARNING: numerical errors not valid for pseudo-plastic till\n")
      PISM.verbPrintf(1,grid.com, "NUMERICAL ERRORS in velocity relative to exact solution:\n")

      vel_ssa = self.solver.ssa.get_advective_2d_velocity()
      
      vel_ssa.begin_access()

      exactvelmax = 0; gexactvelmax = 0;
      for (i,j) in self.grid.points():
        x=grid.x[i]; y=grid.y[j]
        (uexact,vexact) = self.exactSolution(i,j,x,y);
        exactnormsq=math.sqrt(uexact*uexact+vexact*vexact);
        exactvelmax = max(exactnormsq,exactvelmax);
        solution = vel_ssa[i,j]
        uerr = abs(solution.u-uexact)
        verr = abs(solution.v-vexact)
        avuerr += uerr;
        avverr += verr;
        maxuerr = max(maxuerr,uerr);
        maxverr = max(maxverr,verr)
        vecerr = math.sqrt(uerr * uerr + verr * verr);
        maxvecerr = max(maxvecerr,vecerr);
        avvecerr = avvecerr + vecerr;

      vel_ssa.end_access();
      
      gexactvelmax = PISM.globalMax(exactvelmax,grid.com);      
      gmaxuerr     = PISM.globalMax(maxuerr,grid.com);
      gmaxverr     = PISM.globalMax(maxverr,grid.com);
      gavuerr      = PISM.globalSum(avuerr,grid.com) / (grid.Mx*grid.My)
      gavverr      = PISM.globalSum(avverr,grid.com) / (grid.Mx*grid.My)
      gmaxvecerr   = PISM.globalMax(maxvecerr,grid.com)
      gavvecerr    = PISM.globalMax(avvecerr,grid.com) / (grid.Mx*grid.My)

      report_velocity_scale = PISM.secpera
      PISM.verbPrintf(1,grid.com, "velocity  :  maxvector   prcntavvec      maxu      maxv       avu       avv\n");
      #FIXME: variable arguments to verbPrintf are not working.  For now, do the string formatting on the python side.  Maybe
      #this is the best approach.
      PISM.verbPrintf(1,grid.com, "           %11.4f%13.5f%10.4f%10.4f%10.4f%10.4f\n",
                      gmaxvecerr*report_velocity_scale, (gavvecerr/gexactvelmax)*100.0,
                      gmaxuerr*report_velocity_scale, gmaxverr*report_velocity_scale, gavuerr*report_velocity_scale, 
                      gavverr*report_velocity_scale) 
      PISM.verbPrintf(1,grid.com, "NUM ERRORS DONE\n")


  def exactSolution(self,i,j,xi,xj):
    raise NotImplementedError()

  def write(self,filename):
    SSARun.write(self,filename)
    
    grid=self.grid
    exact = util.standard2dVelocityVec(grid,name="_exact",desc="SSA exact solution",intent="diagnostic")
    exact.begin_access()
    for (i,j) in grid.points():
      exact[i,j] = self.exactSolution(i,j,grid.x[i],grid.y[j])
    exact.end_access();
    exact.write(filename);

class SSAFromBootFile(SSARun):
  def __init__(self,boot_file):
    SSARun.__init__(self)
    self.grid = PISM.Context().newgrid()
    self.config = self.grid.config
    self.boot_file = boot_file

  def _setFromOptions(self):
    config = self.config

    # FIXME (DAM 4/28/11)
    # These options probably don't belong here.  Seems like IceBasalResistancePlasticLaw
    # should be able to set these for itself.  
    for o in PISM.OptionsGroup(title="Options for pseudo-plastic ice law"):
      # // use pseudo plastic instead of pure plastic; see iMbasal.cc
      config.flag_from_option("pseudo_plastic", "do_pseudo_plastic_till")

      # // power in denominator on pseudo_plastic_uthreshold; typical is q=0.25; q=0 is pure plastic
      config.scalar_from_option("pseudo_plastic_q", "pseudo_plastic_q")
      if PISM.optionsIsSet("-pseudo_plastic_q"):
        config.set_flag("do_pseudo_plastic_till", True)

      # // threshold; at this velocity tau_c is basal shear stress
      config.scalar_from_option("pseudo_plastic_uthreshold", "pseudo_plastic_uthreshold")
      if PISM.optionsIsSet("-pseudo_plastic_uthreshold"):
        config.set_flag("do_pseudo_plastic_till", True);

      # // controls regularization of plastic basal sliding law
      config.scalar_from_option("plastic_reg", "plastic_regularization")

    for o in PISM.OptionsGroup(title="BasalTillStrength"):
      # // plastic_till_c_0 is a parameter in the computation of the till yield stress tau_c
      # // from the thickness of the basal melt water bwat
      # // Note: option is given in kPa.
      config.scalar_from_option("plastic_c0", "till_c_0");

      # // till_pw_fraction is a parameter in the computation of the till yield stress tau_c
      # // from the thickness of the basal melt water bwat
      # // option a pure number (a fraction); no conversion
      config.scalar_from_option("plastic_pwfrac", "till_pw_fraction")


      config.flag_from_option("thk_eff", "thk_eff_basal_water_pressure")

      if PISM.optionsIsSet("-use_ssa_when_grounded"):
        config.scalar_from_option("use_ssa_when_grounded", "use_ssa_when_grounded")
      else:
        # We're using the SSA, and PISM.PISMYieldStress needs to know this
        # to compute yeild stresses.
        config.set_flag("use_ssa_when_grounded",True);

  def _initGrid(self):
    # FIXME: allow specification of Mx and My different from what's
    # in the boot_file.
    PISM.util.init_grid_from_file(self.grid,self.boot_file,
                                  periodicity=PISM.XY_PERIODIC);

  def _initPhysics(self):
    config = self.config
    basal = PISM.IceBasalResistancePlasticLaw(
           config.get("plastic_regularization") / PISM.secpera,
           config.get_flag("do_pseudo_plastic_till"),
           config.get("pseudo_plastic_q"),
           config.get("pseudo_plastic_uthreshold") / PISM.secpera);

    enthalpyconverter = PISM.EnthalpyConverter(config)
    if PISM.getVerbosityLevel() >3:
      enthalpyconverter.viewConstants(PETSc.Viewer.STDOUT())

    if PISM.optionsIsSet("-ssa_glen"):
      ice = PISM.CustomGlenIce(self.grid.com,"",config,enthalpyconverter)
      B_schoof = 3.7e8;     # Pa s^{1/3}; hardness 
      ice.setHardness(B_schoof)
    else:
      ice =  PISM.GPBLDIce(self.grid.com, "", config,enthalpyconverter)
    ice.setFromOptions()

    self.solver.setPhysics(ice,basal,enthalpyconverter)

  def _initSSACoefficients(self):
    # Read PISM SSA related state variables
    solver = self.solver
    solver.allocateCoeffs()

    thickness = solver.thickness; bed = solver.bed; enthalpy = solver.enthalpy
    mask = solver.ice_mask; surface = solver.surface

    # Read in the PISM state variables that are used directly in the SSA solver
    for v in [thickness, bed, enthalpy]:
      v.regrid(self.boot_file,True)

    # variables mask and surface are computed from the geometry previously read
    sea_level = 0 # FIXME setFromOption?
    gc = PISM.GeometryCalculator(sea_level,self.solver.ice,self.config)
    gc.compute(bed,thickness,mask,surface)

    # Compute yield stress from PISM state variables
    # (basal melt rate, tillphi, and basal water height)
    grid = self.grid

    ds = netCDF.Dataset(self.boot_file)
    has_tauc = ds.variables.has_key('tauc')
    ds.close()
    
    if has_tauc:
      solver.tauc.regrid(self.boot_file,True)
    else:
      bmr   = PISM.util.standardBasalMeltRateVec(grid)
      tillphi = PISM.util.standardTillPhiVec(grid)
      bwat = PISM.util.standardBasalWaterVec(grid)
      for v in [bmr,tillphi,bwat]:
         v.regrid(self.boot_file,True)
      pvars = PISM.PISMVars()
      for v in [thickness,bed,mask,bmr,tillphi,bwat]:
         pvars.add(v)

      yieldstress = PISM.PISMDefaultYieldStress(grid,grid.config)
      yieldstress.init(pvars) 
      yieldstress.basal_material_yield_stress(solver.tauc)
