# Copyright (C) 2011 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM
from PISM import IceModelVec2S, IceModelVec2V, netCDF
import sys, time

class Access:
  def __init__(self,nocomm=None,comm=None):
    if not nocomm is None:
      if isinstance(nocomm,list) or isinstance(nocomm,tuple):
        self.nocomm = nocomm
      else:
        self.nocomm = [nocomm]
      for v in self.nocomm:
        v.begin_access()
    else:
      self.nocomm = None

    if not comm is None:
      if isinstance(comm,list) or isinstance(comm,tuple):
        self.comm = comm
      else:
        self.comm = [comm]
      for v in self.comm:
        v.begin_access()
    else:
      self.comm = None
  def __enter__(self):
    pass
  def __exit__(self,exc_type, exc_value, traceback):
    if not self.nocomm is None:
      for v in self.nocomm:
        v.end_access()
      self.nocomm = None
    
    if not self.comm is None:
      for v in self.comm:
        v.end_access()
        v.beginGhostComm()
        v.endGhostComm()
      self.comm = None

WIDE_STENCIL=2

def writeProvenance(outfile,message=None):
  """Saves the time and command line arguments (or the provided message) to 
  the history attribute of the NC file 'outfile'"""
  rank = PISM.Context().rank
  if rank == 0:
    nc = netCDF.Dataset(outfile, 'a')  # append
    if message is None:
      message = time.asctime() + ': ' + ' '.join(sys.argv)
    if 'history' in nc.ncattrs():
      nc.history = message + '\n' + nc.history
    else:
      nc.history = message
    nc.close()
  PISM.Context().com.barrier()

def standardIceSurfaceVec(grid,name='usurf'):
  surface = IceModelVec2S();
  surface.create(grid, name, True, grid.max_stencil_width)
  surface.set_attrs("diagnostic", "ice upper surface elevation", "m", "surface_altitude");
  return surface;

def standardIceThicknessVec(grid,name='thk'):
  thickness = IceModelVec2S();
  thickness.create(grid, name, True, grid.max_stencil_width);
  thickness.set_attrs("model_state", "land ice thickness", "m", "land_ice_thickness");
  thickness.set_attr("valid_min", 0.0);
  return thickness

def standardBedrockElevationVec(grid,name='topg'):
  bed = IceModelVec2S()
  bed.create(grid, name, True, grid.max_stencil_width);
  bed.set_attrs("model_state", "bedrock surface elevation", "m", "bedrock_altitude");
  return bed

def standardYieldStressVec(grid,name='tauc'):
  # yield stress for basal till (plastic or pseudo-plastic model)
  tauc = IceModelVec2S()
  tauc.create(grid, name, True, grid.max_stencil_width);
  tauc.set_attrs("diagnostic", "yield stress for basal till (plastic or pseudo-plastic model)", "Pa", ""); 
  return tauc;

def standardEnthalpyVec(grid,name='enthalpy'):
  enthalpy = PISM.IceModelVec3()
  enthalpy.create(grid, name, True, grid.max_stencil_width);
  enthalpy.set_attrs("model_state", "ice enthalpy (includes sensible heat, latent heat, pressure)", "J kg-1", "");
  return enthalpy;

def standardBasalMeltRateVec(grid,name='bmelt'):
  bmr = IceModelVec2S()
  bmr.create(grid, "bmelt", True, grid.max_stencil_width);
  bmr.set_attrs("model_state",
                 "ice basal melt rate in ice thickness per time",
                 "m s-1", "land_ice_basal_melt_rate")
  bmr.set_glaciological_units("m year-1")
  bmr.write_in_glaciological_units = True;
  bmr.set_attr("comment", "positive basal melt rate corresponds to ice loss");
  return bmr
  
def standardTillPhiVec(grid,name='tillphi'):
  tillphi = IceModelVec2S()
  tillphi.create(grid,name,True,grid.max_stencil_width)
  # // ghosted to allow the "redundant" computation of tauc
  # // PROPOSED standard_name = land_ice_basal_material_friction_angle
  tillphi.set_attrs("climate_steady", "friction angle for till under grounded ice sheet",
                    "degrees", "")
  tillphi.time_independent = True
  return tillphi

def standardBasalWaterVec(grid,name='bwat'):
  bwat = IceModelVec2S()
  bwat.create(grid,name,True,grid.max_stencil_width)
  bwat.set_attrs("model_state", "effective thickness of subglacial melt water",
                 "m", "")
  #// NB! Effective thickness of subglacial melt water *does* vary from 0 to hmelt_max meters only.
  bwat.set_attr("valid_min", 0.0)
  valid_max = PISM.global_config().get("bwat_max")
  bwat.set_attr("valid_max", valid_max )
  return bwat

def standard2dVelocityVec(grid,name="",desc="",intent=""):
  if name is None: name="" # FIXME
  vel = IceModelVec2V();
  vel.create(grid,name,True,grid.max_stencil_width)
  vel.set_attrs(intent, "%s%s" %("X-component of the ",desc), "m s-1", "", 0);
  vel.set_attrs(intent, "%s%s" %("Y-component of the ",desc), "m s-1", "", 1);
  vel.set_glaciological_units("m year-1");
  vel.write_in_glaciological_units = True
  huge_vel = 1e6/PISM.secpera;
  attrs = [ ("valid_min", -huge_vel), ("valid_max", huge_vel), ("_FillValue", 2*huge_vel) ]
  for a in attrs: 
    for component in range(2):
      vel.set_attr(a[0],a[1],component)
  vel.set(2*huge_vel)
  return vel

def standardDrivingStress(grid,name="ssa_driving_stress",desc="driving stress",intent="model_state"):
  if name is None: name="" # FIXME
  stress = IceModelVec2V();
  stress.create(grid,name,True,grid.max_stencil_width)
  stress.set_attrs(intent, "%s%s" %("X-component of the ",desc), "Pa", "", 0);
  stress.set_attrs(intent, "%s%s" %("Y-component of the ",desc), "Pa", "", 1);

  return stress


def standardVelocityMisfitWeight(grid,name="vel_misfit_weight"):
  vel_misfit_weight = PISM.IceModelVec2S();
  vel_misfit_weight.create(grid, name, True, PISM.util.WIDE_STENCIL)
  vel_misfit_weight.set_attrs("diagnostic", "weight for surface velocity misfit functional", "", "");
  return vel_misfit_weight

def standardCBar(grid,name="cbar"):
  cbar = IceModelVec2S()
  cbar.create(grid, name, False);
  cbar.set_attrs("diagnostic",
                 "magnitude of vertically-integrated horizontal velocity of ice",
                 "m s-1", "")
  cbar.set_glaciological_units("m year-1")
  cbar.set_attr("valid_min", 0.0);
  cbar.write_in_glaciological_units = True
  return cbar


def standardVelSurfaceMask(grid,name="vel_surface_mask"):
  vel_surface_mask = PISM.IceModelVec2Int()
  vel_surface_mask.create(grid, name, False);
  vel_surface_mask.set_attrs("diagnostic", "velocity observations mask", "", "");
  mask_values=[0,1]
  vel_surface_mask.set_attr("flag_values", mask_values);
  vel_surface_mask.set_attr("flag_meanings","no_observed observed");
  vel_surface_mask.output_data_type = PISM.NC_BYTE;
  return vel_surface_mask

def standardIceMask(grid,name='mask'):
  ice_mask = PISM.IceModelVec2Int()
  ice_mask.create(grid, name, True, grid.max_stencil_width);
  ice_mask.set_attrs("model_state", "grounded_dragging_floating integer mask", "", "");
  mask_values=[PISM.MASK_ICE_FREE_BEDROCK, PISM.MASK_GROUNDED, PISM.MASK_FLOATING,
               PISM.MASK_ICE_FREE_OCEAN]
  ice_mask.set_attr("flag_values", mask_values);
  ice_mask.set_attr("flag_meanings","ice_free_bedrock dragging_sheet floating ice_free_ocean");
  ice_mask.output_data_type = PISM.NC_BYTE;
  return ice_mask

def standardBCMask(grid,name='bc_mask'):
  bc_mask = PISM.IceModelVec2Int()
  bc_mask.create(grid, name, True, grid.max_stencil_width);
  bc_mask.set_attrs("model_state", "grounded_dragging_floating integer mask", "", "");
  mask_values=[0,1]
  bc_mask.set_attr("flag_values", mask_values);
  bc_mask.set_attr("flag_meanings","no_data ssa_dirichlet_bc_location");
  bc_mask.output_data_type = PISM.NC_BYTE;
  return bc_mask


def standardLongitudeVec(grid,name="lon"):
  longitude = PISM.IceModelVec2S()
  longitude.create(grid, name, True)
  longitude.set_attrs("mapping", "longitude", "degree_east", "longitude")
  longitude.time_independent = True
  longitude.set_attr("coordinates", "")
  longitude.set_attr("grid_mapping", "")
  return longitude

def standardLatitudeVec(grid,name="lat"):
  latitude = PISM.IceModelVec2S()
  latitude.create(grid, name, True)
  latitude.set_attrs("mapping", "latitude", "degree_east", "latitude")
  latitude.time_independent = True
  latitude.set_attr("coordinates", "")
  latitude.set_attr("grid_mapping", "")
  return latitude


def init_shallow_grid(grid,Lx,Ly,Mx,My,p):
  grid.Lx = Lx;
  grid.Ly = Ly;
  grid.periodicity = p;
  grid.start_year = grid.year = 0.0;
  grid.Mx = Mx; grid.My=My; grid.Mz=3;

  grid.compute_nprocs();
  grid.compute_ownership_ranges();
  grid.compute_vertical_levels()
  grid.compute_horizontal_spacing();
  grid.createDA();

def init_grid(grid,Lx,Ly,Lz,Mx,My,Mz,p):
  grid.Lx = Lx;
  grid.Ly = Ly;
  grid.Lz = Lz;
  grid.periodicity = p;
  grid.start_year = grid.year = 0.0;
  grid.Mx = Mx; grid.My=My; grid.Mz = Mz;

  grid.compute_nprocs();
  grid.compute_ownership_ranges();
  grid.compute_vertical_levels()
  grid.compute_horizontal_spacing();
  grid.createDA();

def init_grid_from_file(grid,bootfile,periodicity=PISM.NONE):
  pio = PISM.PISMIO(grid)
  pio.get_grid(bootfile,'enthalpy')
  grid.periodicity=periodicity

  grid.compute_nprocs();
  grid.compute_ownership_ranges();
  grid.compute_horizontal_spacing();
  grid.createDA()

  # grid.createDA()
  # pio.open_for_reading(bootfile)
  # grid_info = PISM.grid_info(); pio.get_grid_info( "enthalpy", grid_info )
  # pio.close()
  # 
  # grid.Mx = grid_info.x_len;
  # grid.My = grid_info.y_len;
  # grid.x0 = grid_info.x0;
  # grid.y0 = grid_info.y0;
  # grid.Lx = grid_info.Lx;
  # grid.Ly = grid_info.Ly;
  # 
  # grid.compute_nprocs();
  # grid.compute_ownership_ranges();
  # grid.compute_horizontal_spacing();
  # grid.set_vertical_levels(grid_info.zlevels);
  # grid.createDA()
  


def init_grid2d_from_file(grid,bootfile,Mx=None,My=None):
  pio = PISM.PISMIO(grid)
  pio.open_for_reading(bootfile)
  grid_info = PISM.grid_info(); pio.get_grid_info( "land_ice_thickness", grid_info )
  pio.close()

  grid.Mx = grid_info.x_len;
  grid.My = grid_info.y_len;
  grid.Mz = 2;
  grid.x0 = grid_info.x0;
  grid.y0 = grid_info.y0;
  grid.Lx = grid_info.Lx;
  grid.Ly = grid_info.Ly;

  if not Mx is None:
    grid.Mx = Mx
  if not My is None:
    grid.My = My

  grid.compute_nprocs();
  grid.compute_ownership_ranges();
  grid.compute_horizontal_spacing();
  grid.compute_vertical_levels();
  grid.createDA()


