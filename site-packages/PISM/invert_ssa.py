# Copyright (C) 2011, 2012 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM
try:
  import siple
except:
  raise Exception("PISM.invert_ssa requires the siple python library.\nInstall from https://github.com/damaxwell/siple")
import math
from petsc4py import PETSc

from siple.gradient.forward import NonlinearForwardProblem
from siple.gradient.nonlinear import InvertNLCG, InvertIGN
from siple.reporting import msg

from PISM.sipletools import PISMLocalVector
from math import sqrt
import numpy as np

tauc_param_types = {"ident":PISM.InvTaucParamIdent, 
               "square":PISM.InvTaucParamSquare,
               "exp":PISM.InvTaucParamExp,
               "trunc":PISM.InvTaucParamTruncatedIdent }

class TaucParamFactory:
  def create(self, config, name=None ):
    if name is None:
      name = PISM.optionsList(PISM.Context().com,"-inv_ssa_tauc_param","zeta->tauc parameterization",["ident","square","exp","trunc"],"")
      if name == "":
        name = config.get_string("inv_ssa_tauc_param")
    tauc_param = tauc_param_types[name]()
    tauc_param.init(config)
    return tauc_param

tauc_param_factory = TaucParamFactory()

WIDE_STENCIL = 2

def invSSAFactory(grid,basal,ec,tauc_param,config,name=None):
  if name is None:
    name = config.get_string("inv_ssa_method")
  if name.startswith('tikhonov'):
    return PISM.InvSSATikhonov(grid,basal,ec,tauc_param,config)
  return PISM.InvSSAForwardProblem(grid,basal,ec,tauc_param,config)

class InvSSARun(PISM.ssa.SSARun):

  def setup(self):

    PISM.ssa.SSARun.setup(self)

    vecs = self.modeldata.vecs

    # The SSA instance will not keep a reference to pismVars; it only uses it to extract
    # its desired variables.  So it is safe to pass it pismVars and then let pismVars
    # go out of scope at the end of this method.

    self.ssa.init(vecs.asPISMVars())

    if vecs.has('vel_bc'):
      self.ssa.set_boundary_conditions(vecs.bc_mask,vecs.vel_bc)

    # Cache the values of the coefficients at quadrature points once here.
    # Subsequent solves will then not need to cache these values.
    self.ssa.cacheQuadPtValues();

    # YUCK
    inv_method = self.config.get_string('inv_ssa_method');
    if inv_method.startswith('tikhonov'):
      self.ssa.set_functionals()

  def _constructSSA(self):
    md = self.modeldata
    self.tauc_param = tauc_param_factory.create(self.config)
    return invSSAFactory(md.grid,md.basal,md.enthalpyconverter,self.tauc_param,self.config)

def InvSSASolver(ssarun):
  """Returns an inverse solver appropriate for the config variable 'inv_ssa_method'.
  The problem :ssarun: should be a subclass of :InvSSARun:.""" 
  method = ssarun.config.get_string('inv_ssa_method')
  if method.startswith('tikhonov'):
    return InvSSASolver_Tikhonov(ssarun)
  if method == 'sd' or method == 'nlcg' or method == 'ign':
    return InvSSASolver_Siple(ssarun)
  raise Exception("Unknown inverse method '%s'; unable to construct solver.",method)

class InvSSASolver_Tikhonov:
  """Inverse SSA solver based on Tikhonov iteration using TAO."""
  
  tao_types = {'tikhonov_lmvm':'tao_lmvm', 'tikhonov_cg':'tao_cg', 'tikhonov_lcl':'tao_lcl'}

  def __init__(self,ssarun):
    self.ssarun = ssarun
    self.config = ssarun.config

    self.method = self.config.get_string('inv_ssa_method')

    self.listeners = []

  def solveForward(self,zeta,out=None):
    ssa = self.ssarun.ssa

    if not ssa.linearizeAt(zeta):
      raise Exception("")
    if out is not None:
      out.copy_from(ssa.solution())
    else:
      out = ssa.solution()
    return out

  def addIterationListener(self,listener):
    self.listeners.append(listener)

  def addXUpdateListener(self,listener):
    self.listeners.append(listener)

  def solveInverse(self,zeta0,u_obs):
    eta = self.config.get("inv_ssa_tikhonov_eta")

    tao_type = self.tao_types[self.method]
    if self.method == 'tikhonov_lcl':
      self.ip = PISM.InvSSA_LCLTikhonov(self.ssarun.ssa,zeta0,u_obs,eta)
      self.solver = PISM.InvSSA_LCLTikhonovSolver(self.ssarun.grid.com,tao_type,self.ip)
    else:
      self.ip = PISM.InvSSATikhonovProblem(self.ssarun.ssa,zeta0,u_obs,eta)
      self.solver = PISM.InvSSATikhonovSolver(self.ssarun.grid.com,tao_type,self.ip)

    pl = [ TikhonovIterationListenerAdaptor(self,l) for l in self.listeners ]
    for l in pl:
      self.ip.addListener(l)

    return self.solver.solve()

  def inverseSolution(self):
    zeta = self.ip.designSolution()
    u =    self.ip.stateSolution()
    return (zeta,u)

  def inverseConvergedReason(self):
    return self.solver.reasonDescription()

class InvSSASolver_Siple:
  """Inverse SSA solver based on siple iteratve methods."""

  def __init__(self,ssarun):
    self.ssarun = ssarun
    self.config = ssarun.config
    self.converged_reason = "No Problem Solved"

    self.method = self.config.get_string('inv_ssa_method')

    self.rms_error = self.config.get("inv_ssa_rms_error") / PISM.secpera

    self.forward_problem = SSAForwardProblem(ssarun)

    # Determine the inversion algorithm, and set up its arguments.
    if self.method == "ign":
      Solver = InvertSSAIGN
    else:
      Solver = InvertSSANLCG

    params=Solver.defaultParameters()
    if self.method == "sd":
      params.steepest_descent = True
      params.ITER_MAX=10000
    elif self.method =="ign":
      params.linearsolver.ITER_MAX=10000
      params.linearsolver.verbose = True
    # if ls_verbose:
    #   params.linesearch.verbose = True
    params.verbose   = True
    params.deriv_eps = 0.

    # Run the inversion
    self.solver=Solver(self.forward_problem,params=params)

  def solveForward(self,zeta,out=None):
    if out is None:
      out = self.forward_problem.F(PISMLocalVector(zeta))
    else:
      out = self.forward_problem.F(PISMLocalVector(zeta),out=PISMLocalVector(out))
    return out.core()

  def addIterationListener(self,listener):
    self.solver.addIterationListener(SipleIterationListenerAdaptor(self,listener))

  def addXUpdateListener(self,listener):
    self.solver.addXUpdateListener(SipleXUpdateListenerAdaptor(self,listener))

  def addLinearIterationListener(self,listener):
    self.solver.addLinearIterationListener(SipleLinearIterationListenerAdaptor(self,listener))

  def solveInverse(self,zeta0,u_obs):
    try:
      (self.zeta_i,self.u_i) = self.solver.solve(zeta0,u_obs,self.rms_error)
    except Exception:
      exc_type, exc_value, exc_traceback = sys.exc_info()
      
      self.converged_reason = traceback.format_exception(exc_type, exc_value,
                                                         exc_traceback)
      # It would be nice to make siple so that if the inverse solve failse
      # you can still keep the most recent iteration. 
      self.u_i = None
      self.zeta_i = None
      return False
    self.converged_reason = "Morozov Discrepancy Met"
    return True

  def inverseSolution(self):
    return (self.zeta_i,self.u_i)

  def inverseConvergedReason(self):
    return self.converged_reason


class SSAForwardProblem(NonlinearForwardProblem):
  
  def __init__(self,ssarun):
    self.ssarun = ssarun
    self.ssa = self.ssarun.ssa
    self.grid = ssarun.grid

  def F(self, x,out=None,guess=None):
    """
    Returns the value of the forward problem at x.

    Nonlinear problems often make use of an initial guess; this can be provided in 'guess'.

    Storage in 'out', if given, is used for the return value.
    """
    # if not guess is None:
    #   self.solver.set_initial_velocity_guess(guess)
    if out is None:
      out = self.rangeVector()
    self.ssa.set_zeta(x.core())
    self.ssa.solveF(out.core())
    return out

  def T(self,d,out=None):
    """
    Returns the value of the linearization, T, of F, at the point x specified previously in linearizeAt, 
    in the direction d.

    Storage in 'out', if given, is used for the return value.
    """
    if out is None:
      out = self.rangeVector()
    self.ssa.solveT(d.core(),out.core())
    return out

  def TStar(self,r,out=None):
    """
    Let T be the linearization of F at the point x (at the point x specified previously in linearizeAt).  
    Its adjoint is T*.  This method returns the value of T* in the direction r.

    Storage in 'out', if given, is used for the return value.
    """
    if out is None:
      out = self.domainVector()
    self.ssa.solveTStar(r.core(),out.core())
    return out

  def linearizeAt(self,x,guess=None):
    """
    Instructs the class that subsequent calls to T and TStar will be conducted for the given value of x.

    Nonlinear problems often make use of an initial guess; this can be provided in 'guess'.
    """
    self.ssa.set_zeta(x.core())

  def evalFandLinearize(self,x,out=None,guess=None):
    """
    Computes the value of F(x) and locks in a linearization.  Sometimes there are efficiencies that
    can be acheived this way.

    Default implementation simply calls F, then linearizeAt.
    """
    if out is None:
      out = self.rangeVector()
    self.linearizeAt(x)
    self.ssa.solveF(out.core())
    return out
  
  def rangeIP(self,a,b):
    """
    Computes the inner product of two vectors in the range.
    """
    return self.ssa.rangeIP(a.core(),b.core())

  def domainIP(self,a,b):
    """
    Computes the inner product of two vectors in the domain.
    """
    return self.ssa.domainIP(a.core(),b.core())

  def rangeVector(self):
    """Constructs a brand new vector from the range vector space"""
    v = PISM.IceModelVec2V()
    v.create(self.grid,"",True,WIDE_STENCIL)

    # Add appropriate meta data.
    intent = "?inverse?" # FIXME
    desc = "SSA velocity computed by inversion"
    v.set_attrs(intent, "%s%s" %("X-component of the ",desc), "m s-1", "", 0);
    v.set_attrs(intent, "%s%s" %("Y-component of the ",desc), "m s-1", "", 1);
    v.set_glaciological_units("m year-1");
    v.write_in_glaciological_units = True
    huge_vel = 1e6/PISM.secpera;
    attrs = [ ("valid_min", -huge_vel), ("valid_max", huge_vel), ("_FillValue", 2*huge_vel) ]
    for a in attrs: 
      for component in range(2):
        v.set_attr(a[0],a[1],component)

    return PISMLocalVector(v)

  def domainVector(self):
    """Constructs a brand new vector from the domain vector space"""
    v = PISM.IceModelVec2S()
    v.create(self.grid,"",True,WIDE_STENCIL)
    return PISMLocalVector(v)

class SSAForwardProblemFIXME(NonlinearForwardProblem):

  def __init__(self,ssarun):
    self.ssarun = ssarun
    self.ssa = self.ssarun.ssa
    self.grid = ssarun.grid

  def F(self, x,out=None,guess=None):
    """
    Returns the value of the forward problem at x.

    Nonlinear problems often make use of an initial guess; this can be provided in 'guess'.

    Storage in 'out', if given, is used for the return value.
    """
    if out is None:
      out = self.rangeVector()
    self.ssa.linearizeAt(x.core())
    out.core().copy_from(self.ssa.solution())
    return out

  def T(self,d,out=None):
    """
    Returns the value of the linearization, T, of F, at the point x specified previously in linearizeAt, 
    in the direction d.

    Storage in 'out', if given, is used for the return value.
    """
    if out is None:
      out = self.rangeVector()
    self.ssa.computeT(d.core(),out.core())
    out.core().beginGhostComm()
    out.core().endGhostComm()
    return out

  def TStar(self,r,out=None):
    """
    Let T be the linearization of F at the point x (at the point x specified previously in linearizeAt).  
    Its adjoint is T*.  This method returns the value of T* in the direction r.

    Storage in 'out', if given, is used for the return value.
    """
    if out is None:
      out = self.domainVector()
    self.ssa.evalGradPenaltyReduced(r.core(),out.core())
    out.core().beginGhostComm()
    out.core().endGhostComm()
    out.core().scale(0.5)
    return out

  def linearizeAt(self,x,guess=None):
    """
    Instructs the class that subsequent calls to T and TStar will be conducted for the given value of x.

    Nonlinear problems often make use of an initial guess; this can be provided in 'guess'.
    """
    # self.ssa.set_zeta(x.core())
    self.ssa.linearizeAt(x.core())

  def evalFandLinearize(self,x,out=None,guess=None):
    """
    Computes the value of F(x) and locks in a linearization.  Sometimes there are efficiencies that
    can be acheived this way.

    Default implementation simply calls F, then linearizeAt.
    """
    if out is None:
      out = self.rangeVector()
    self.ssa.linearizeAt(x.core())
    out.core().copy_from(self.ssa.solution())
    return out

  def rangeIP(self,a,b):
    """
    Computes the inner product of two vectors in the range.
    """
    return self.ssa.rangeIP(a.core(),b.core())

  def domainIP(self,a,b):
    """
    Computes the inner product of two vectors in the domain.
    """
    bc = b.core()
    return self.ssa.domainIP(a.core(),b.core())

  def rangeVector(self):
    """Constructs a brand new vector from the range vector space"""
    v = PISM.IceModelVec2V()
    v.create(self.grid,"",PISM.kHasGhosts,WIDE_STENCIL)

    # Add appropriate meta data.
    intent = "?inverse?" # FIXME
    desc = "SSA velocity computed by inversion"
    v.set_attrs(intent, "%s%s" %("X-component of the ",desc), "m s-1", "", 0);
    v.set_attrs(intent, "%s%s" %("Y-component of the ",desc), "m s-1", "", 1);
    v.set_glaciological_units("m year-1");
    v.write_in_glaciological_units = True
    huge_vel = 1e6/PISM.secpera;
    attrs = [ ("valid_min", -huge_vel), ("valid_max", huge_vel), ("_FillValue", 2*huge_vel) ]
    for a in attrs: 
      for component in range(2):
        v.set_attr(a[0],a[1],component)

    return PISMLocalVector(v)

  def domainVector(self):
    """Constructs a brand new vector from the domain vector space"""
    v = PISM.IceModelVec2S()
    v.create(self.grid,"",True,WIDE_STENCIL)
    return PISMLocalVector(v)


class InvertSSANLCG(InvertNLCG):
  """
  Inversion of the map

    F: gamma |-> u

  where u is the solution of the PDE

    -Laplacian u + gamma u = f

  F is a map from L^2 to L^2.
  """

  @staticmethod
  def defaultParameters():
    params = InvertNLCG.defaultParameters()
    return params

  def __init__(self,forward_problem,params=None):
    InvertNLCG.__init__(self,params)
    self.forward_problem = forward_problem

  def forwardProblem(self):
    return self.forward_problem

  def stopConditionMet(self,count,x,Fx,y,r):
    """
    Determines if minimization should be halted (based, e.g. on a Morozov discrepancy principle)

    In: count: current iteration count
        x:     point in domain of potential minimizer.
        Fx:    value of nonlinear function at x
        r:     current residual, i.e. y-F(x)    
    """

    J = sqrt(abs(self.forward_problem.rangeIP(r,r)));

    msg('(%d) J=%g goal=%g',count,J*PISM.secpera,self.Jgoal*PISM.secpera)

    if( J < self.Jgoal ):
      msg('Stop condition met')
      return True
    return False

  def initialize(self,x,y,deltaLInf):
    """
    Hook called at the start of solve.  This gives the class a chance to massage the input.
    For example, x and y might be dolfin (finite element) Functions; this method should return 
    the associated dolfin GenericVectors.

    The remaining arguments are passed directly from solve, and can be used for determining the
    final stopping criterion.

    Returns dolfin vectors corresponding to the initial value of x and the desired value of y=F(x).    
    """
    xv = PISMLocalVector(x)
    yv = PISMLocalVector(y)

    self.Jgoal = self.params.mu*deltaLInf

    return (xv,yv)

  def finalize(self,x,y):
    """
    Hook called at the end of 'solve'.  Gives the chance to massage the return values.
    """
    tauc = x.core()
    u = y.core()
    return (tauc,u)

  def solve(self,x,y,deltaLInf):
    """
    Solve the ill posed problem F(x)=y where y is know to an L infinity error deltaLInf
    """
    return InvertNLCG.solve(self,x,y,deltaLInf)


class InvertSSAIGN(InvertIGN):
  """
  Inversion of the map

    F: gamma |-> u

  where u is the solution of the PDE

    -Laplacian u + gamma u = f

  F is a map from L^2 to L^2.
  """

  @staticmethod
  def defaultParameters():
    params = InvertIGN.defaultParameters()
    return params

  def __init__(self,forward_problem,params=None):
    InvertIGN.__init__(self,params)
    self.forward_problem = forward_problem

  def forwardProblem(self):
    return self.forward_problem

  def temper_d(self, x,d,y,r):
    dnorm = d.norm('linf');  xnorm = x.norm('linf')
    if dnorm > 2*xnorm:
      msg('wild change predicted by linear step. scaling')
      d.scale(2*xnorm/dnorm)

  def initialize(self,x,y,deltaLInf):
    """
    Hook called at the start of solve.  This gives the class a chance to massage the input.
    For example, x and y might be dolfin (finite element) Functions; this method should return 
    the associated dolfin GenericVectors.

    The remaining arguments are passed directly from solve, and can be used for determining the
    final stopping criterion.

    Returns dolfin vectors corresponding to the initial value of x and the desired value of y=F(x).    
    """
    xv = PISMLocalVector(x)
    yv = PISMLocalVector(y)

    Jgoal = deltaLInf

    return (xv,yv,Jgoal)

  def finalize(self,x,y):
    """
    Hook called at the end of 'solve'.  Gives the chance to massage the return values.
    """

    tauc = x.core()
    u = y.core()

    return (tauc,u)

  def solve(self,x,y,deltaLInf):
    """
    Solve the ill posed problem F(x)=y where y is know to an L infinity error deltaLInf
    """
    return InvertIGN.solve(self,x,y,deltaLInf)

class LinearPlotListener:  
  def __init__(self,grid):
    self.tz_scalar = PISM.toproczero.ToProcZero(grid,dof=1)
    self.tz_vector = PISM.toproczero.ToProcZero(grid,dof=2)

  def __call__(self,solver,count,x,y,d,r,*args):
    from matplotlib import pyplot as pp
    import siple
    d = self.tz_scalar.communicate(d.core())
    x = self.tz_scalar.communicate(x.core())
    r = self.tz_vector.communicate(r.core())
    y = self.tz_vector.communicate(y.core())

    if not d is None:
      r *= PISM.secpera
      y *= PISM.secpera

      self.iteration(solver,count,x,y,d,r,*args)

  def iteration(self,solver,count,x,y,d,r,*args):
    # Subclasses should implement this method to do 
    # the plotting. This method will only be called on
    # processor zero, and the arguments will all be numpy
    # vectors already copied to proc 0.
    raise NotImplementedError()


class Bunch:
  def __init__(self, **kwds):
      self.__dict__.update(kwds)

  def has_key(self,k):
    return self.__dict__.has_key(k)

  def update(self,**kwds):
    self.__dict__.update(**kwds)

  def __repr__(self):
      keys = self.__dict__.keys()
      return 'Bunch(%s)'%', '.join(['%s=%s'%(k,self.__dict__[k]) for k in keys])

class TikhonovIterationListenerAdaptor(PISM.PythonTikhonovSVListener):
  """Adaptor for passing listening events from a TAO-based Tikhonov solver to a python object."""
  def __init__(self,owner,listener):
    PISM.PythonTikhonovSVListener.__init__(self)
    self.owner = owner
    self.listener = listener
  def iteration(self,it,eta,objVal,penaltyVal,d,diff_d,grad_d,u,diff_u,grad_u,grad):
    data = Bunch(eta=eta,designVal=objVal,stateVal=penaltyVal,
                      zeta=d,diff_zeta=diff_d,grad_zeta=grad_d,
                      u=u,r=diff_u,grad_u=grad_u,grad=grad)
    try:
      self.listener(self.owner,it,data)
    except Exception as e:
      PISM.verbPrintf(1,PISM.Context().com,"\nWARNING: Exception occured during an inverse solver listener callback:\n%s\n\n" % str(e))

class SipleIterationListenerAdaptor:
  """Adaptor for passing listening events from siple-based solvers to a python object."""
  def __init__(self,owner,listener):
    self.owner = owner
    self.listener = listener
  def __call__(self,siplesolver,it,x,Fx,y,d,r,*args):    
    data = Bunch(zeta=x.core(),u=Fx.core(),u_obs=y.core(),d_zeta=d.core(),r=r.core(),rms_error=self.owner.rms_error)

    if self.owner.method == 'ign':
      data.update(Td=args[0].core())
    else:
      data.update(TStarR=args[0].core())
    try:
      self.listener(self.owner,it,data)
    except Exception as e:
      PISM.verbPrintf(1,PISM.Context().com,"\nWARNING: Exception occured during an inverse solver listener callback:\n%s\n\n" % str(e))

class SipleLinearIterationListenerAdaptor:
  """Adaptor for passing listening events the linear steps of siple-based ign solvers to a python object."""
  def __init__(self,owner,listener):
    self.owner = owner
    self.listener = listener

  def __call__(self,siplesolver,it,x, y, d, r, Td, TStarR):    

    data = Bunch(x=x.core(),y=y.core(),r=r.core(),d=d.core(),Td=Td.core(),TSTarR=TStarR.core())
    try:
      self.listener(self.owner,it,data)
    except Exception as e:
      PISM.verbPrintf(1,PISM.Context().com,"\nWARNING: Exception occured during an inverse solver listener callback:\n%s\n\n" % str(e))

class SipleXUpdateListenerAdaptor:
  """Adaptor for passing listening events the linear steps of siple-based ign solvers to a python object."""
  def __init__(self,owner,listener):
    self.owner = owner
    self.listener = listener

  def __call__(self,siplesolver,it,zeta,u,u_obs,r):    
    data = Bunch(zeta=zeta.core(),u=u.core(),r=r.core(),u_obs=u_obs.core())
    try:
      self.listener(self.owner,it,data)
    except Exception as e:
      PISM.verbPrintf(1,PISM.Context().com,"\nWARNING: Exception occured during an inverse solver XUpdate listener callback:\n%s\n\n" % str(e))

def printTikhonovProgress(invssasolver,it,data):
  eta = data.eta
  stateVal = data.stateVal
  designVal = data.designVal

  if eta<1:
    sWeight = eta
    dWeight = 1
  else:
    sWeight = 1
    dWeight = 1./eta

  com = PISM.Context().com
  v = 2
  PISM.verbPrintf(v,com,"----------------------------------------------------------\n");
  PISM.verbPrintf(v,com,"Iteration %d\n" % it)    
  PISM.verbPrintf(v,com,"RMS misfit: %g\n" % math.sqrt(stateVal))
  PISM.verbPrintf(v,com,"sqrt(design objective) %g; weighted %g\n" % (math.sqrt(designVal),math.sqrt(designVal*dWeight))) 
  PISM.verbPrintf(v,com,"gradient: design %g state %g sum %g\n" % (data.grad_zeta.norm(PETSc.NormType.NORM_2)*dWeight,data.grad_u.norm(PETSc.NormType.NORM_2)*sWeight,data.grad.norm(PETSc.NormType.NORM_2)))
  PISM.verbPrintf(v,com,"tikhonov functional: %g\n" % (stateVal*sWeight + designVal*dWeight) )


def printRMSMisfit(invssa_solver,it,data):
  if invssa_solver.method.startswith('tikhonov'):
    rms_misfit = math.sqrt(data.stateVal)
  else:
    fp = invssa_solver.forward_problem
    r=PISMLocalVector(data.r)
    rms_misfit = math.sqrt(fp.rangeIP(r,r))*PISM.secpera
  com = PISM.Context().com
  v = 2
  PISM.verbPrintf(v,com,"Iteration [%d]: RMS misfit %g\n" % (it,rms_misfit));

class ZetaSaver:
  """Iteration listener used to save a copy of the current value
  of zeta (i.e. parameterized tauc) at each iteration during an inversion."""
  def __init__(self,output_filename):
    self.output_filename = output_filename

  def __call__(self,inverse_solver,count,data):
    zeta = data.zeta
    # The solver doesn't care what the name of zeta is, and we
    # want it called 'zeta_inv' in the output file, so we rename it.
    zeta.rename('zeta_inv', 'last iteration of parameterized basal yeild stress computed by inversion','')
    zeta.write(self.output_filename)

class MonitorAdjoint:
  def __init__(self):
    self.Td = None
    self.TStarR = None
    self.didWarning = False

  def __call__(self,inverse_solver,count,data):
    method = inverse_solver.method
    if method != 'sd' and method !='nlcg' and method != 'ign':
      if not self.didWarning:
        PISM.verbPrintf(1,PISM.Context().com,'\nWarning: unable to monitor adjoint for inverse method: %s\nOption -inv_monitor_adjoint ignored\n' % method)
      self.didWarning = True
      return
    fp = inverse_solver.forward_problem
    d = PISMLocalVector(data.d)
    r = PISMLocalVector(data.r)
    self.Td=fp.T(d,self.Td)
    self.TStarR=forward_problem.TStar(r,out=self.TStarR)
    ip1 = fp.domainIP(d,self.TStarR)
    ip2 = fp.rangeIP(self.Td,r)
    siple.reporting.msg("adjoint test: <Td,r>=%g <d,T^*r>=%g (percent error %g)",ip1,ip2,(abs(ip1-ip2))/max(abs(ip1),abs(ip2)))


class MonitorAdjointLin:
  def __init__(self):
    self.Td = None
    self.TStarR = None

  def __call__(self,inverse_solver,count,data):
    fp = inverse_solver.forward_problem
    r = PISM.sipletools.PISMLocalVector(data.r)
    d = PISM.sipletools.PISMLocalVector(data.d)
    self.Td=fp.T(d,self.Td)
    self.TStarR=forward_problem.TStar(r,out=self.TStarR)
    ip1 = fp.domainIP(d,self.TStarR)
    ip2 = fp.rangeIP(self.Td,r)
    siple.reporting.msg("adjoint test: <Td,r>=%g <d,T^*r>=%g (percent error %g)",ip1,ip2,(abs(ip1-ip2))/max(abs(ip1),abs(ip2)))

def pauseListener(*args):
    siple.reporting.pause()

class PlotListener:
  def __init__(self,grid):
    self.grid = grid
    self.tz_scalar = PISM.toproczero.ToProcZero(grid,dof=1)
    self.tz_vector = PISM.toproczero.ToProcZero(grid,dof=2)
    self.fig = None

  def toproczero(self,v):
    if v.get_dof()==1:
      return self.tz_scalar.communicate(v)
    return self.tz_vector.communicate(v)

  def figure(self):
    if self.fig == None:
      import matplotlib.pyplot as pp
      self.fig = pp.figure()
    return self.fig.number

  def iteration(self,solver,itr,data):
    # Subclasses should implement this method to do 
    # the plotting. This method will only be called on
    # processor zero, and the arguments will all be numpy
    # vectors already copied to proc 0.
    raise NotImplementedError()

