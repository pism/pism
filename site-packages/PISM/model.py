# Copyright (C) 2011 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM, math
from PISM import util, netCDF

class ModelVecs:
  def __init__(self):
    self.needs_writing = set()
    self._vecs = {}
    self.pvarnames = {}

  def __getattr__(self,key):
    v = self._vecs.get(key)
    if v is None:
      raise AttributeError(key)
    return v

  def __repr__(self):
    s= 'ModelVecs:\n'
    for (key,value) in self._vecs.items():
      s += "    %s: %s %s\n" %(key,value,value.string_attr("name"))
    return s

  def get(self,name):
    v = self._vecs.get(key)
    if v is None:
      raise AttributeError(key)
    return v

  def add(self,var,name=None,writing=False):
    if name is None:
      name = var.string_attr("name")
    if self._vecs.has_key(name):
      raise RuntimeError("Cannot add variable %s to model.ModelVecs; it is already present" % name)
    self._vecs[name] = var
    if writing:
      self.needs_writing.add(var)
  
  def rename(self,old_name,new_name):
    var = self._vecs.pop(old_name)
    self.add(var,new_name)

  def remove(self,name):
    v = self._vecs.pop(name)
    if v in self.needs_writing:
      self.needs_writing.remove(v)
    if self.pvarnames.has_key(name):
      self.pvarnames.remove(name)

  def has(self,var):
    return self._vecs.has_key(var)

  def items( self ):
    for (name,var) in self._vecs.items():
      yield (name,var)

  def asPISMVars(self):
    pismVars = PISM.PISMVars()
    for (name,var) in self.items():
      pv_name = self.pvarnames.get(name)
      if pv_name is not None:
        pismVars.add(var,pv_name)
      else:
        pismVars.add(var)
    return pismVars

  def setPISMVarsName(self,varname,pvarname):
    if not self.has(varname):
      raise RuntimeError("Cannot set export name for %s to %s: variable %s does not exist." %(varname,pvarname,varname))
    self.pvarnames[varname]=pvarname

  def write(self,output_filename):
    vlist = [ v for v in self.needs_writing ]
    vlist.sort(cmp=var_cmp)
    for v in vlist:
      v.write(output_filename)

  def writeall(self,output_filename):
    vlist = [ var for (name,var) in self.items() ]
    vlist.sort(cmp=var_cmp)
    for v in vlist:
      v.write(output_filename)

  def markForWriting(self,var):
    if isinstance(var,str):
      var = self.get(var)
    self.needs_writing.add(var)

# There must be a better way to do this.
def var_cmp(v1,v2):
  n1 = v1.string_attr("name")
  n2 = v2.string_attr("name")
  if n1 < n2:
    return -1
  if n1 > n2:
    return 1
  return 0

class ModelData:
  def __init__(self,grid,config=None):
    self.grid = grid
    if config is None: config = grid.config
    self.config = config

    # Components for the physics
    self.ice   = None
    self.basal = None
    self.enthalpyconverter = None

    self.vecs = ModelVecs()

  def setPhysics(self,basal,enthalpyconverter):
    self.basal = basal;
    self.enthalpyconverter = enthalpyconverter;
