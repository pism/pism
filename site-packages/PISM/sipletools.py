# Copyright (C) 2011, 2012 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM
import time
import numpy as np
try:
  import siple
except:
  raise Exception("PISM.sipletools requires the siple python library.\nInstall from https://github.com/damaxwell/siple")
from petsc4py import PETSc

class PISMLocalVector(siple.linalg.AbstractVector):
  """Implements the siple.linalg.AbstractVector interface for few kinds of PISM IceModelVec."""
  def __init__(self,u):
    if isinstance(u,PISM.IceModelVec2S):
      self._core = u
      self.dof = 1
    elif isinstance(u,PISM.IceModelVec2V):
      self._core = u
      self.dof = 2
    else:
      raise ValueError("An PISMLocalVector wraps PISM IceModelVec2S or IceModelVec2V: found a %s" % u)
    self.grid = u.get_grid()
  
  def set(self,rhs):
    self._core.copy_from(rhs._core)
  
  def acc(self,rhs):
    self._core.add(1.,rhs._core)
  
  def scale(self,t):
    self._core.scale(t)
  
  def axpy(self,t,v):
    self._core.add(t,v._core)
  
  def copy(self):
    c = self.vector_like()
    self._core.copy_to(c._core)
    return c
  
  def vector_like(self):
    if self.dof == 1:
      c = PISM.IceModelVec2S()
    else:
      c = PISM.IceModelVec2V()    
    c.create(self.grid,"",True,self._core.get_stencil_width())
    return PISMLocalVector(c)
    
  def zero_like(self):
    z = self.vector_like()
    z._core.set(0.)
    return z
  
  def dim(self):
    grid = self._core.get_grid()
    return self.dof*grid.Mx*grid.My
  
  def core(self):
    return self._core

  def norm(self,name):
    if name == 'linf':
      return self._core.norm(PETSc.NormType.NORM_INFINITY)
    if name == 'l2':
      return self._core.norm(PETSc.NormType.NORM_2)
    if name == 'l1':
      return self._core.norm(PETSc.NormType.NORM_1)
    
    raise ValueError()

class CaptureLogger:
  """Implements a siple logger that records log messages and can tag
  the messages to the siple_log attribute of an NC file."""
  def __init__(self):
    self.diary =""
    siple.reporting.add_logger(self)
    self.rank = PISM.Context().rank
    self.com = PISM.Context().com

  def __call__(self,message,severity):
    if self.rank == 0:
      self.diary += message
      self.diary += "\n"

  def write(self,outfile):
    if self.rank == 0:
      d = PISM.netCDF.Dataset(outfile,'a')
      if 'siple_log' in d.ncattrs():
        d.siple_log = self.diary + "\n" + d.siple_log
      else:
        d.siple_log = self.diary
      d.close()
    self.com.barrier()

class CarefulCaptureLogger:
  """Implements a siple logger that appends log messages as they occur 
  to the siple_log attribute of an NC file."""
  def __init__(self,filename):
    self.com = PISM.Context().com
    self.rank = PISM.Context().rank
    self.log = ""
    if PISM.Context().rank == 0:
      self.filename = filename
      d = PISM.netCDF.Dataset(self.filename,'a')
      if 'siple_log' in d.ncattrs():
        self.log = d.siple_log
      d.close()
    else:
      self.filename = None
    self.com.barrier()
    siple.reporting.add_logger(self)

  def __call__(self,message,severity):
    if self.rank == 0:
      timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
      self.log = "%s\n%s: %s" % (self.log,timestamp,message)
      d = PISM.netCDF.Dataset(self.filename,'a')
      d.siple_log = self.log
      d.close()
    self.com.barrier()

  def write(self,output_filename):
    if self.rank == 0:
      d = PISM.netCDF.Dataset(output_filename,'a')
      if 'siple_log' in d.ncattrs():
        d.siple_log = self.log + "\n" + d.siple_log
      else:
        d.siple_log = self.log
      d.close()
    self.com.barrier()

def pism_print_logger(message,severity):
  """Implements a siple logger that prints output to the terminal."""
  verb = severity
  com = PISM.Context().com
  PISM.verbPrintf(verb,com, "%s\n" % message)

def pism_pause(message_in=None,message_out=None):
  """Implements a siple pause callback appropriate for parallel runs."""
  import sys, os
  fd = sys.stdin.fileno()
  com = PISM.Context().com
  if os.isatty(fd):
    return siple.reporting.std_pause(message_in,message_out)
  if not message_in is None:
    PISM.verbPrintf(1,com,message_in+"\n")
  import sys
  ch = sys.stdin.read(1)
  if not message_out is None:
    PISM.verbPrintf(1,com,message_out+"\n")

def randVectorS(grid,scale,stencil_width=None):
  rv = PISM.IceModelVec2S();
  if stencil_width is None:
    rv.create(grid, 'rand vec', False)
  else:
    rv.create(grid, 'rand vec', True, stencil_width)
  shape=(grid.xm,grid.ym)
  r = np.random.normal(scale=scale,size=shape)
  with PISM.util.Access(nocomm=rv):
    for (i,j) in grid.points():
      rv[i,j] = r[i-grid.xs,j-grid.ys]
  if stencil_width is not None:
    rv.beginGhostComm(); rv.endGhostComm()
  return rv

def randVectorV(grid,scale,stencil_width=None):
  rv = PISM.IceModelVec2V();
  if stencil_width is None:
    rv.create(grid, 'rand vec', False)
  else:
    rv.create(grid, 'rand vec', True,stencil_width)

  shape=(grid.xm,grid.ym)
  r_u = np.random.normal(scale=scale,size=shape)
  r_v = np.random.normal(scale=scale,size=shape)
  with PISM.util.Access(nocomm=rv):
    for (i,j) in grid.points():
      rv[i,j].u = r_u[i-grid.xs,j-grid.ys]
      rv[i,j].v = r_v[i-grid.xs,j-grid.ys]
    if stencil_width is not None:
      rv.beginGhostComm(); rv.endGhostComm()
  return rv

