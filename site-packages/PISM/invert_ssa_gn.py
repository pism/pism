# Copyright (C) 2012 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# FIXME: TAO initialization here??

import PISM
from PISM.util import Bunch

def constructFunctionals(ssarun):
  vecs = ssarun.modeldata.vecs
  if vecs.has('vel_misfit_weight'):
    misfit_weight = vecs.vel_misfit_weight

  misfit_weight = None
  if vecs.has('vel_misfit_weight'):
    misfit_weight = vecs.vel_misfit_weight

  tauc_fixed_mask = None
  if vecs.has('zeta_fixed_mask'):
    tauc_fixed_mask = vecs.zeta_fixed_mask

  grid = ssarun.grid
  cL2 = grid.config.get("inv_ssa_cL2");
  cH1 = grid.config.get("inv_ssa_cH1");

  area = 4*grid.Lx*grid.Ly;
  length_scale = grid.config.get("inv_ssa_length_scale");
  cL2 /= area;
  cH1 /= area;
  cH1 *= (length_scale*length_scale);

  designFunctional = PISM.H1NormFunctional2S(grid,cL2,cH1,tauc_fixed_mask)    

  velocity_scale = grid.config.get("inv_ssa_velocity_scale")/PISM.secpera;

  stateFunctional = PISM.MeanSquareFunctional2V(grid,misfit_weight);    
  stateFunctional.normalize(velocity_scale);
  
  return (designFunctional,stateFunctional)

class InvSSASolver_Tikhonov:

  def __init__(self,ssarun,method):
    self.ssarun = ssarun
    self.method = method
    self.config = ssarun.config
    self.method = self.config.get_string('inv_ssa_method')
    self.listeners = []

  def solveForward(self,zeta,out=None):
    ssa = self.ssarun.ssa

    if not ssa.linearize_at(zeta):
      raise Exception("")
    if out is not None:
      out.copy_from(ssa.solution())
    else:
      out = ssa.solution()
    return out

  def addIterationListener(self,listener):
    self.listeners.append(listener)

  def addXUpdateListener(self,listener):
    self.listeners.append(listener)

  def solveInverse(self,zeta0,u_obs,zeta_inv):
    eta = self.config.get("tikhonov_penalty_weight")

    (stateFunctional,designFunctional) = constructFunctionals(self.ssarun)
    self.solver = PISM.InvSSATikhonovGN(self.ssarun.ssa,zeta0,u_obs,eta,stateFunctional,designFunctional)
#    pl = [ TikhonovIterationListenerAdaptor(self,l) for l in self.listeners ]
    pl = []
    for l in pl:
      self.solver.addListener(l)
    self.solver.setInitialGuess(zeta_inv)

    if PISM.optionsFlag("-inv_test_adjoint",""):
      self.solver.init()
      grid = self.ssarun.grid
      d1 = PISM.util.randVectorS(grid,1)
      d2 = PISM.util.randVectorS(grid,1)
      y1 = PISM.IceModelVec2S()
      y1.create(grid,'',PISM.kNoGhosts)
      y2 = PISM.IceModelVec2S()
      y2.create(grid,'',PISM.kNoGhosts)
      self.solver.apply_GN(d1,y1)
      self.solver.apply_GN(d2,y2)
      ip1 = y1.get_vec().dot(d2.get_vec())
      ip2 = y2.get_vec().dot(d1.get_vec())
      PISM.logging.logMessage("ip1 %.10g ip2 %.10g\n" % (ip1,ip2) )
      PISM.logging.logMessage("ip1 %g ip2 %g\n" % (ip1,ip2) )
      exit(0)

    self.solver.solve()
    
    return True

  def inverseSolution(self):
    zeta = self.solver.designSolution()
    u =    self.solver.stateSolution()
    return (zeta,u)

  def inverseConvergedReason(self):
    return "FIXME"
#    return self.solver.reasonDescription()

# class TikhonovIterationListenerAdaptor(PISM.InvSSATikhonovListener):
#   """Adaptor for passing listening events from a TAO-based Tikhonov solver to a python object."""
#   def __init__(self,owner,listener):
#     PISM.InvSSATikhonovListener.__init__(self)
#     self.owner = owner
#     self.listener = listener
#   def iteration(self,problem,eta,it,objVal,penaltyVal,d,diff_d,grad_d,u,diff_u,grad_u,grad):
#     data = Bunch(eta=eta,designVal=objVal,stateVal=penaltyVal,
#                       zeta=d,diff_zeta=diff_d,grad_zeta=grad_d,
#                       u=u,r=diff_u,grad_u=grad_u,grad=grad)
#     try:
#       self.listener(self.owner,it,data)
#     except Exception as e:
#       logError("\nWARNING: Exception occured during an inverse solver listener callback:\n%s\n\n" % str(e))
#     return 0